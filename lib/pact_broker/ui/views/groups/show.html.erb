<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Network Graph</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="">
<meta name="author" content="Duncan Alexander">
<script type="text/javascript" src="/javascripts/d3.v3.js.pagespeed.ce.dFNRrGTALe.js"></script>
<style>body{font-family:"Helvetica Neue",Arial,sans-serif;font-size:.75em;font-weight:bold;padding:2em}#legend{display:inline-block;width:600;height:70}</style>
<!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
<!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<!-- developed by Duncan Alexander - hypothete.com -->
</head>
<body>
<h1>Network graph of pacticipantName relationships</h1>
<div id="legend" </div>
<script type="text/javascript">
var windowWidth, windowHeight, svg;

var enlargeCanvasToFit = function (radius) {
    //Make SVG canvas bigger if it won't fit
    if (3 * radius > windowWidth) {
        windowWidth = 3 * radius;
        svg.attr("width", windowWidth);
    }
    if (3.5 * radius > windowHeight) {
        windowHeight = 3.5 * radius;
        svg.attr("height", windowHeight);
    }
};

var parseCSV = function (data) {
    var pacticipants = [];
    data.forEach(
        function(row) {
            var pacticipant = {
                id: row[0],
                pacticipantName: row[1],
                order: parseInt(row[5]),
                connectedPacticipantIds: row.slice(6).filter(function(e) {
                    if (parseInt(e) != NaN && parseInt(e) > 0) {
                        return e;
                    }
                })
            };

            pacticipants.push(pacticipant);
        });
    pacticipants.sort(function(a, b) {
        return d3.ascending(a.order, b.order);
    });
    return pacticipants;
};

var getPacticipantNames = function (pacticipants) {
    return pacticipants.map(function(p){ return p.pacticipantName });
};

var relationshipPath = function(relationship, nodeLocations, pacticipants) {
    var dx = nodeLocations[relationship[1]].x - nodeLocations[relationship[0]].x;
    var dy = nodeLocations[relationship[1]].y - nodeLocations[relationship[0]].y;
    var dr = Math.sqrt(dx * dx + dy * dy);
    var inout = 1;
    if ((nodeLocations[relationship[1]].i > nodeLocations[relationship[0]].i && Math.abs(nodeLocations[relationship[1]].i - nodeLocations[relationship[0]].i) <= pacticipants.length / 2) || (nodeLocations[relationship[1]].i < nodeLocations[relationship[0]].i && Math.abs(nodeLocations[relationship[1]].i - nodeLocations[relationship[0]].i) >= pacticipants.length / 2)) {
        inout = 0;
    }
    return "M" + 0 + "," + 0 + "A" + dr + ", " + dr + " 0 0," + inout + " " + dx + "," + dy;
};

var relationshipData = function(pacticipant, relationships) {
    var relationshipsInvolvingPacticipant = [];
    relationships.forEach(function(relationship) {
        var dummyRelationship = [];
        if (relationship.consumerId == pacticipant.id) {
            dummyRelationship[0] = relationship[0];
            dummyRelationship[1] = relationship[1];
            if (relationship.relationshipType) {
                dummyRelationship.relationshipType = relationship.relationshipType;
            } else {
                dummyRelationship.relationshipType = 'consumer';
            }
            relationshipsInvolvingPacticipant.push(dummyRelationship);
        } else if (relationship.providerId == pacticipant.id) {
            dummyRelationship[0] = relationship[1];
            dummyRelationship[1] = relationship[0];
            if (relationship.relationshipType) {
                dummyRelationship.relationshipType = relationship.relationshipType;
            } else {
                dummyRelationship.relationshipType = 'provider';
            }
            relationshipsInvolvingPacticipant.push(dummyRelationship);
        }
    });
    return relationshipsInvolvingPacticipant;
};

var createRelationships = function (pacticipants) {
    var relationships = [];
    pacticipants.forEach(function(d) {
        d.connectedPacticipantIds.forEach(function(connectedPacticipantId) {
            relationships.push([d.id, connectedPacticipantId]);
            relationships.push(
            {
                0: d.id,
                1: connectedPacticipantId,
                consumerId: d.id,
                providerId: connectedPacticipantId
            }
            );
        });
    });
    relationships.forEach(function(relationship) {
        for (var i = 0; i < relationships.length; i++) {
            if (relationship.consumerId == relationships[i].providerId
                && relationship.providerId == relationships[i].consumerId) {
                relationships.splice(i, 1);
                relationship[2] = 2;
                relationship.relationshipType = 'bidirectional';
            }
        }
    });
    relationships.sort(function(a, b) {
        return d3.ascending(a[0], b[0]);
    });

    return relationships;

};

var transformPacticipantNode = function (d, i, radius, pacticipants, nodeLocations) {
    //Node locations - makes the big circle
    var x = radius * Math.cos(2 * Math.PI * (i / pacticipants.length)) + windowWidth / 2;
    var y = radius * Math.sin(2 * Math.PI * (i / pacticipants.length)) + windowHeight / 2;
    nodeLocations[d.id] = {
        x: x,
        y: y,
        i: i
    };
    return "translate(" + x + "," + y + ")";
};

var relationshipColour = function(relationship) {
    if (relationship.relationshipType == 'consumer') {
        return "red";
    } else if (relationship.relationshipType == 'provider') {
        return "teal";
    } else {
        return "purple";
    }
};

var pacticipantMouseover = function() {
    svg.selectAll("path").transition().duration(500).attr("opacity", "0.1");
    d3.select(this.parentNode).selectAll("path").transition().duration(500).attr("opacity", "1").attr("stroke-width", "1");
};
var pacticipantMouseout = function() {
    svg.selectAll("path").transition().duration(500).attr("stroke-width", ".35").attr("opacity", ".5");
};

var textContent = function(d, i) { return this.parentNode.className.animVal; };

window.onload = function() {
    var legendHeight = 200;
    windowWidth = window.innerWidth;
    windowHeight = window.innerHeight - legendHeight;
    svg = d3.select("body").append("svg").attr("width", windowWidth).attr("height", windowHeight).attr("version", 1.1).attr("xmlns", "http://www.w3.org/2000/svg");
    var pacticipants = [];
    var maxrad = 0;
    var pacticipantNameArray = [];
    var circleMinRadius = 150;

    d3.text("<%= csv_path %>", "text/csv", function(unparsedData) {
        var data=d3.csv.parseRows(unparsedData);
        pacticipants = parseCSV(data);
        pacticipantNameArray = getPacticipantNames(pacticipants);

        var nodeLocations = {};
        var radius = Math.max(circleMinRadius, pacticipants.length * 2.5);

        enlargeCanvasToFit(radius, windowWidth, windowHeight, svg);

        maxrad = (radius * Math.PI / pacticipants.length) + 2;
        var g = svg.selectAll("g").data(pacticipants).enter().append("g").attr("transform", function(d, i) {
            return transformPacticipantNode(d, i, radius, pacticipants, nodeLocations);
        }).attr("id", function(d, i) {
            return i;
        }).attr("class", function(pacticipant) {
            return pacticipant.pacticipantName;
        });

        relationships = createRelationships(pacticipants);

        g.selectAll("path").data(function(pacticipant){
            return relationshipData(pacticipant, relationships);
        }).enter()
        .append("path")
        .attr("d", function(d){ return relationshipPath(d, nodeLocations, pacticipants); })
        .attr("stroke", relationshipColour).attr("stroke-width", ".35")
        .attr("opacity", ".5")
        .attr("fill", "none")
        .attr("class", function(d) {
            return d[0] + " " + d[1] + " " + nodeLocations[d[0]].i;
        });

        var pacticipantColour = d3.scale.category10().domain([0, pacticipants.length]);

        var onRight = function (i) {
            return i <= pacticipants.length / 4 || i >= pacticipants.length * 3 / 4;
        };

        var textFill = function(pacticipant) {
            return pacticipantColour(pacticipant.order);
        }

        var circleXOffset = function(d, i) {
            //controls the positioning in regards to the edge of the circle
            return 3 * Math.cos(2 * Math.PI * i / pacticipants.length);
        };

        var circleYOffset = function(d, i) {
            //controls the positioning in regards to the edge of the circle
            return 3 * Math.sin(2 * Math.PI * i / pacticipants.length);
        };

        var circles = g.append("circle")
        .attr("r", function(pacticipant) { return 4; })
        .attr("fill", textFill)
        .attr("stroke", textFill)
        .attr("stroke-width", 2)
        .attr("cx", circleXOffset)
        .attr("cy", circleYOffset);

        // var textRotation = function(d, i) {
        //     if(onRight(i)){
        //         return "rotate(" + 90 * Math.sin(2 * Math.PI * i / pacticipants.length) + ")";
        //     } else {
        //         return "rotate(" + -90 * Math.sin(2 * Math.PI * i / pacticipants.length) + ")";
        //     }
        // };

        var textAnchor = function(d, i) {
            if (onRight(i)) {
                return "start";
            } else {
                return "end";
            }
        };

        var textXOffset = function(d, i) {
            //controls the positioning in regards to the edge of the circle
            return 40 * Math.cos(2 * Math.PI * i / pacticipants.length);
        };

        var isFinite = function(num) {
            return !(num == Number.POSITIVE_INFINITY || num == Number.NEGATIVE_INFINITY)
        };


        var textYOffset = function(d, i) {
            var thing = 4 * Math.PI * i / pacticipants.length;
            var counterOffset = 0;

            counterOffset = (0.2 / (20 * Math.tan(thing/2))) * 1000;

            if(!isFinite(counterOffset)) { //Right, middle node
                counterOffset = 0;
            } else {
                //Near the asymptotes, it gets bigger really quickly, if it's a big number,
                //it's likely it should actually be on the asymptote, and therefore, have no counterOffset
                if(Math.abs(counterOffset) > 30) {
                    //Left, middle node
                    counterOffset = 0;
                }
            }

            return (40 * Math.sin(2 * Math.PI * i / pacticipants.length)) - counterOffset;
        };

        var textYOffset2 = function(d, i) {
            console.debug(d.pacticipantName, i, (40 * Math.sin(2 * Math.PI * i / pacticipants.length)))
            return (40 * Math.sin(2 * Math.PI * i / pacticipants.length));
        };

        var text = g.append("text").text(textContent)
        .attr("x", function(d, i) { return textXOffset(d, i, maxrad); })
        .attr("y", function(d, i) { return textYOffset(d, i, maxrad); })
        .attr("text-anchor", textAnchor)
        .attr("fill", textFill);

        circles.on("mouseover", pacticipantMouseover).on("mouseout", pacticipantMouseout);

        legend = d3.select("#legend").append("svg").attr("width", 600).attr("height", 70);

        var lineLength = 20;

        var connlines = legend.selectAll("line").data([0, 1, 2]).enter().append("line").attr("x1", lineLength).attr("y1", function(d, i) {
            return 5 + 25 * d;
        }).attr("x2", lineLength * 4).attr("y2", function(d, i) {
            return 5 + 25 * d;
        }).attr("stroke", function(d) {
            if (d == 0) {
                return "red";
            } else if (d == 1) {
                return "teal";
            }
            return "purple";
        }).attr("stroke-width", 2);

        legend.append("text").text("is a consumer of").attr("x", lineLength * 5).attr("y", 10).attr("fill", "black");
        legend.append("text").text("is a provider for").attr("x", lineLength * 5).attr("y", 35).attr("fill", "black");
        legend.append("text").text("is a consumer and a provider of").attr("x", lineLength * 5).attr("y", 60).attr("fill", "black");
    });
}</script>
</body>
</html>